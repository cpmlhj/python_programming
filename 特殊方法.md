下面给出 Python 3.11 全部魔法方法的完整 Markdown 表格清单。

为便于阅读，按功能分组，每组一个表格。

所有“限制 / 注意”均用 一句话 标注，方便快速查阅。

---

0. 元数据与帮助（只读或解释器自动填充）

魔法方法	触发场景	限制 / 注意	
`__doc__`	`help()` / `obj.__doc__`	类体第一个字符串自动写入，手动赋值无效（只读）。	
`__annotations__`	注解字典	运行时手动改不影响类型检查器。	
`__module__`	`repr` / `pickle` 显示模块名	解释器自动填，改值不干扰导入系统。	
`__qualname__`	限定名	只读，赋值静默失效。	
`__slots__`	内存优化	定义后实例不再拥有 `__dict__`；子类需重新声明。	

---

1. 对象生命周期

魔法方法	触发场景	限制 / 注意	
`__new__(cls, …)`	创建实例	必须返回该类或其子类实例，否则 `__init__` 被跳过；元类签名不同。	
`__init__(self, …)`	实例已创建	不能返回非 `None` 值；`__new__` 返回非实例时不会执行。	
`__del__(self)`	引用归零	不保证立即调用；解释器退出可能跳过；循环引用+定义 `__del__` 无法被 gc 自动回收。	

---

2. 属性访问（点号运算符）

魔法方法	触发场景	限制 / 注意	
`__getattribute__(self, name)`	任何属性读取	一旦定义，`__getattr__` 默认不再触发；易无限递归，需 `super()` 代理。	
`__getattr__(self, name)`	查无属性	若定义 `__getattribute__`，本方法永不会被隐式调用。	
`__setattr__(self, name, value)`	`obj.x = v`	在 `__init__` 内也会触发；必须 `super()` 或直接操作 `__dict__`，否则递归。	
`__delattr__(self, name)`	`del obj.x`	同上；类属性不受拦截。	

---

3. 描述符协议（仅类变量且通过实例访问时生效）

魔法方法	触发场景	限制 / 注意	
`__get__(self, inst, owner=None)`	实例/类读取	若实例为 `None`，返回 `self`；实例属性同名不会触发。	
`__set__(self, inst, value)`	实例写入	无 `__set__` 时为 non-data descriptor，实例属性可覆盖它。	
`__delete__(self, inst)`	`del inst.attr`	仅类变量生效。	

---

4. 容器 / 序列协议

魔法方法	触发场景	限制 / 注意	
`__len__(self)`	`len(obj)`	必须返回 >=0 的整数。	
`__getitem__(self, key)`	`obj[k]`	切片对象也走这里；未实现抛 `TypeError`。	
`__setitem__(self, key, value)`	`obj[k] = v`	只读容器不应定义。	
`__delitem__(self, key)`	`del obj[k]`	不可删除时应主动抛 `TypeError`。	
`__contains__(self, item)`	`item in obj`	未定义时退而迭代+比较，效率低。	
`__reversed__(self)`	`reversed(obj)`	未定义时退而倒序索引；流式迭代器建议直接实现。	

---

5. 可迭代 / 迭代器

魔法方法	触发场景	限制 / 注意	
`__iter__(self)`	`iter(obj)` / `for`	必须返回迭代器对象（带 `__next__`）。	
`__next__(self)`	`next(it)`	必须抛 `StopIteration` 结束；忘抛会死循环。	
`__aiter__(self)`	`async for`	仅在异步上下文触发；普通 `for` 看不到。	
`__anext__(self)`	`await anext(it)`	同 `__next__`，需抛 `StopAsyncIteration`。	

---

6. 上下文管理器

魔法方法	触发场景	限制 / 注意	
`__enter__(self)`	`with obj as x:`	返回值绑定给 `as` 变量；异常在本方法内已抛，`__exit__` 仍会执行。	
`__exit__(self, exc_type, exc, tb)`	离开 `with` 块	若返回真值，异常被吞掉；签名必须三参数可 `None`。	

---

7. 类型转换 / 内置函数协议

魔法方法	触发场景	限制 / 注意	
`__int__` / `__float__` / `__complex__`	对应内置函数	必须返回对应类型实例。	
`__index__`	`operator.index()` / 位运算	必须返回纯整数；用于切片、hex/bin/oct。	
`__bool__`	`truth value testing`	未定义时退而看 `__len__`；必须返回 `bool`。	
`__hash__`	`hash(obj)` / dict-set 键	可变对象需置 `__hash__ = None`，否则运行期抛 TypeError；与 `__eq__` 一致性请保证。	
`__bytes__`	`bytes(obj)`	必须返回 `bytes` 实例。	
`__format__(self, fmt_spec)`	`format()` / f-string	未定义时退而 `format(str(obj), spec)`。	

---

8. 字符串 / 调试表示

魔法方法	触发场景	限制 / 注意	
`__repr__(self)`	`repr()` / 交互式提示符	建议返回可 eval 字符串；未定义时用 `<...>` 模板。	
`__str__(self)`	`str()` / `print()`	未定义时退而 `__repr__`；对用户友好即可。	

---

9. 比较运算符（rich comparisons）

魔法方法	触发场景	限制 / 注意	
`__eq__` / `__ne__` / `__lt__` / `__le__` / `__gt__` / `__ge__`	`==` `!=` `<` `<=` `>` `>=`	未定义时退而比较 id（地址）；`__ne__` 默认对 `__eq__` 取反；继承不可变类型时请保证哈希一致。	

---

10. 算术 / 位 / 反射 / 就地运算符（40+ 个，统一规则）

类别	魔法方法示例	触发场景	限制 / 注意	
二元算术	`__add__`	`a + b`	返回 `NotImplemented` 则自动试 反射方法 `__radd__`。	
反射	`__radd__`	`3 + obj`	仅当左操作数 返回 NotImplemented 才被调用；内置数字永不返回 `NotImplemented`，需把自定义对象放左侧才能触发。	
就地	`__iadd__`	`a += b`	允许返回任意对象；未定义则退而 `a = a + b`，生成新对象。	
位/移位/整除	`__and__` / `__lshift__` / `__floordiv__` …	同上规则；`__index__` 必须实现才能被当作整数掩码。	

---

11. 序列化（pickle & copy）

魔法方法	触发场景	限制 / 注意	
`__reduce__` / `__reduce_ex__`	`pickle.dumps(obj)`	`__reduce_ex__` 优先，老协议也走这里；`__reduce__` 被忽略。	
`__getnewargs_ex__` / `__getnewargs__`	控制 `__new__` 参数	必须与 `__new__` 签名匹配；新式类才生效。	
`__getstate__` / `__setstate__`	自定义状态	若定义，`__dict__` 不会自动保存，需手动返回/恢复。	

---

12. 元类专用（普通类定义它们 永不执行）

魔法方法	触发场景	限制 / 注意	
`__prepare__`	元类创建命名空间	必须定义在元类中；普通类写此方法等于普通函数。	
`__instancecheck__` / `__subclasscheck__`	`isinstance` / `issubclass`	只有元类或抽象基类定义才有效；实例方法无效。	

---

13. 协程 / 异步 / 可调用等其余方法

魔法方法	触发场景	限制 / 注意	
`__await__`	`await obj`	必须返回 iterator；普通生成器加 `@asyncio.coroutine` 已过时。	
`__aenter__` / `__aexit__`	`async with`	与同步版规则相同，只是返回 awaitable。	
`__call__`	`obj()`	让对象像函数；无参数个数限制；未定义则 TypeError。	

---

14. 解释器独占（不能重定义，写也无效）

魔法方法	说明	
`__dict__` / `__weakref__`	底层槽位，类体定义仅当普通属性，不会替换描述符。	
`__mro__` / `__bases__` / `__base__`	只读元组，赋值抛 AttributeError。	
`__code__` / `__defaults__` …	函数对象专用，类型不匹配会崩溃。	

---

速记口诀（复制贴墙）

1. 双下开头结尾 + 解释器自动调用 → 魔法方法。  
2. 返回类型/签名错 → 抛 TypeError 或被忽略。  
3. 反射/就地/二元 → NotImplemented 是“通行证”。  
4. 元类方法写在普通类 → 永远不会跑。  
5. 生命周期里，`__new__` 才是真构造；`__del__` 不保证执行。

> 以上即 Python 3.11 全部魔法方法的 Markdown 表格速查手册，可直接复制使用。祝编码愉快！